; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;108    
;;;109    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;110    {
;;;111        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L1.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;112    }
00000c  bd10              POP      {r4,pc}
;;;113    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40004040

                          AREA ||i.PWM0_Init||, CODE, READONLY, ALIGN=2

                  PWM0_Init PROC
;;;74     
;;;75     void PWM0_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;76     {
;;;77         /*
;;;78           Configure PWM0 channel 0 init period and duty(down counter type).
;;;79           Period is PLL / (prescaler * (CNR + 1))
;;;80           Duty ratio = CMR / (CNR + 1)
;;;81           
;;;82           Period = 48 MHz / (1 * (199 + 1)) = 240000 Hz
;;;83           Duty ratio = 100 / (199 + 1) = 50%
;;;84         */
;;;85     	
;;;86         /* Set PWM0 timer clock prescaler */
;;;87         PWM_SET_PRESCALER(PWM0, PWM_CHANNEL, PWM_PSC - 1);
000002  4820              LDR      r0,|L2.132|
000004  491e              LDR      r1,|L2.128|
000006  61c1              STR      r1,[r0,#0x1c]
;;;88     	
;;;89         /* Set up counter type */
;;;90         PWM0->CTL1 &= ~PWM_CTL1_CNTTYPE0_Msk;
000008  6841              LDR      r1,[r0,#4]
00000a  0889              LSRS     r1,r1,#2
00000c  0089              LSLS     r1,r1,#2
00000e  6041              STR      r1,[r0,#4]
;;;91     
;;;92         /* Set PWM0 timer period */
;;;93         PWM_SET_CNR(PWM0, PWM_CHANNEL, PWM_CNR);
000010  481c              LDR      r0,|L2.132|
000012  491d              LDR      r1,|L2.136|
000014  3040              ADDS     r0,r0,#0x40
000016  6001              STR      r1,[r0,#0]
;;;94     	
;;;95         /* Set PWM0 timer duty */
;;;96         PWM_SET_CMR(PWM0, PWM_CHANNEL, PWM_CMR);	
000018  2100              MOVS     r1,#0
00001a  6201              STR      r1,[r0,#0x20]
;;;97     	
;;;98         /* Set output level at zero, compare up, period(center) and compare down of specified channel */
;;;99         PWM_SET_OUTPUT_LEVEL(PWM0, PWM_CHANNEL_MASK, PWM_OUTPUT_HIGH, PWM_OUTPUT_LOW, PWM_OUTPUT_NOTHING, PWM_OUTPUT_NOTHING);
00001c  4608              MOV      r0,r1
00001e  2401              MOVS     r4,#1
                  |L2.32|
000020  4621              MOV      r1,r4
000022  4081              LSLS     r1,r1,r0
000024  06c9              LSLS     r1,r1,#27
000026  d51a              BPL      |L2.94|
000028  4916              LDR      r1,|L2.132|
00002a  3180              ADDS     r1,r1,#0x80
00002c  6b0d              LDR      r5,[r1,#0x30]
00002e  2703              MOVS     r7,#3
000030  0042              LSLS     r2,r0,#1
000032  463b              MOV      r3,r7
000034  4093              LSLS     r3,r3,r2
000036  2602              MOVS     r6,#2
000038  439d              BICS     r5,r5,r3
00003a  4096              LSLS     r6,r6,r2
00003c  4335              ORRS     r5,r5,r6
00003e  630d              STR      r5,[r1,#0x30]
000040  6b0d              LDR      r5,[r1,#0x30]
000042  4616              MOV      r6,r2
000044  3610              ADDS     r6,r6,#0x10
000046  40b7              LSLS     r7,r7,r6
000048  43bd              BICS     r5,r5,r7
00004a  630d              STR      r5,[r1,#0x30]
00004c  6b4d              LDR      r5,[r1,#0x34]
00004e  439d              BICS     r5,r5,r3
000050  4623              MOV      r3,r4
000052  4093              LSLS     r3,r3,r2
000054  431d              ORRS     r5,r5,r3
000056  634d              STR      r5,[r1,#0x34]
000058  6b4a              LDR      r2,[r1,#0x34]
00005a  43ba              BICS     r2,r2,r7
00005c  634a              STR      r2,[r1,#0x34]
                  |L2.94|
00005e  1c40              ADDS     r0,r0,#1
000060  2806              CMP      r0,#6
000062  dbdd              BLT      |L2.32|
;;;100    	
;;;101        /* Enable output of PWM0 channel 0 */
;;;102        PWM_EnableOutput(PWM0, PWM_CHANNEL_MASK);
000064  4d07              LDR      r5,|L2.132|
000066  2110              MOVS     r1,#0x10
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       PWM_EnableOutput
;;;103    	
;;;104    	PWM_Start(PWM0, PWM_CHANNEL_MASK);
00006e  2110              MOVS     r1,#0x10
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       PWM_Start
;;;105    	
;;;106    	set_flag(flag_reverse , ENABLE);
000076  4905              LDR      r1,|L2.140|
000078  7808              LDRB     r0,[r1,#0]  ; BitFlag
00007a  4320              ORRS     r0,r0,r4
00007c  7008              STRB     r0,[r1,#0]
;;;107    }
00007e  bdf8              POP      {r3-r7,pc}
;;;108    
                          ENDP

                  |L2.128|
                          DCD      0x000003e7
                  |L2.132|
                          DCD      0x40058000
                  |L2.136|
                          DCD      0x0000bb7f
                  |L2.140|
                          DCD      ||.data||

                          AREA ||i.PWM_Set_Duty||, CODE, READONLY, ALIGN=1

                  PWM_Set_Duty PROC
;;;66     
;;;67     void PWM_Set_Duty(PWM_T *pwm,uint32_t u32ChannelNum,uint32_t u32DutyCycle,uint32_t u32CycleResolution)		// 1 ~ 1000 , 0.1 % to 100%
000000  b570              PUSH     {r4-r6,lr}
;;;68     {
000002  4605              MOV      r5,r0
;;;69         uint32_t u32NewCMR = 0;
;;;70     	u32NewCMR = CalNewDutyCMR(pwm, u32ChannelNum, u32DutyCycle, u32CycleResolution);    
000004  0848              LSRS     r0,r1,#1
000006  00c0              LSLS     r0,r0,#3
000008  1940              ADDS     r0,r0,r5
00000a  6b00              LDR      r0,[r0,#0x30]
00000c  460c              MOV      r4,r1                 ;68
00000e  1c40              ADDS     r0,r0,#1
000010  4350              MULS     r0,r2,r0
000012  4619              MOV      r1,r3
000014  f7fffffe          BL       __aeabi_uidivmod
;;;71     	PWM_SET_CMR(pwm, u32ChannelNum, u32NewCMR);
000018  00a1              LSLS     r1,r4,#2
00001a  1949              ADDS     r1,r1,r5
00001c  6508              STR      r0,[r1,#0x50]
;;;72     }
00001e  bd70              POP      {r4-r6,pc}
;;;73     
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;189    
;;;190    void SYS_Init(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  2059              MOVS     r0,#0x59
000004  4c23              LDR      r4,|L4.148|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L4.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L4.10|
;;;191    {
;;;192        /* Unlock protected registers */
;;;193        SYS_UnlockReg();
;;;194    
;;;195        GPIO_SetMode(PF, BIT2|BIT3, GPIO_MODE_INPUT);
000016  2200              MOVS     r2,#0
000018  210c              MOVS     r1,#0xc
00001a  481f              LDR      r0,|L4.152|
00001c  f7fffffe          BL       GPIO_SetMode
;;;196    
;;;197        /* Enable HIRC clock (Internal RC 48MHz) */
;;;198        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk|CLK_PWRCTL_HXTEN_Msk);
000020  2005              MOVS     r0,#5
000022  f7fffffe          BL       CLK_EnableXtalRC
;;;199    	
;;;200        /* Wait for HIRC clock ready */
;;;201        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk|CLK_STATUS_HXTSTB_Msk);
000026  2011              MOVS     r0,#0x11
000028  f7fffffe          BL       CLK_WaitClockReady
;;;202    	
;;;203    //    /* Disable PLL first to avoid unstable when setting PLL */
;;;204    //    CLK_DisablePLL();
;;;205    
;;;206    //    /* Set PLL frequency */
;;;207    //    CLK->PLLCTL = (CLK->PLLCTL & ~(0x000FFFFFul)) | 0x0008C03Eul;
;;;208    
;;;209    //    /* Waiting for PLL ready */
;;;210    //    CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;211    
;;;212        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;213    //    CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
;;;214        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(1));
00002c  2100              MOVS     r1,#0
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       CLK_SetHCLK
;;;215    
;;;216    //    CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV1 | CLK_PCLKDIV_APB1DIV_DIV1);
;;;217    
;;;218        /* Enable UART0 clock */
;;;219        CLK_EnableModuleClock(UART0_MODULE);
000034  4d19              LDR      r5,|L4.156|
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       CLK_EnableModuleClock
;;;220        CLK_EnableModuleClock(TMR1_MODULE);
00003c  4e18              LDR      r6,|L4.160|
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       CLK_EnableModuleClock
;;;221        CLK_EnableModuleClock(PWM0_MODULE);
000044  4f17              LDR      r7,|L4.164|
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;222    
;;;223        /* Switch UART0 clock source to HIRC */
;;;224        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
00004c  2200              MOVS     r2,#0
00004e  05b9              LSLS     r1,r7,#22
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       CLK_SetModuleClock
;;;225        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
000056  2107              MOVS     r1,#7
000058  2200              MOVS     r2,#0
00005a  0309              LSLS     r1,r1,#12
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       CLK_SetModuleClock
;;;226        CLK_SetModuleClock(PWM0_MODULE, CLK_CLKSEL2_PWM0SEL_PCLK0, 0);
000062  2200              MOVS     r2,#0
000064  2101              MOVS     r1,#1
000066  4638              MOV      r0,r7
000068  f7fffffe          BL       CLK_SetModuleClock
;;;227    
;;;228        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;229        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
00006c  06a8              LSLS     r0,r5,#26
00006e  6bc1              LDR      r1,[r0,#0x3c]
000070  22ff              MOVS     r2,#0xff
000072  0412              LSLS     r2,r2,#16
000074  4391              BICS     r1,r1,r2
000076  2233              MOVS     r2,#0x33
000078  0452              LSLS     r2,r2,#17
00007a  1889              ADDS     r1,r1,r2
00007c  63c1              STR      r1,[r0,#0x3c]
;;;230                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;231    
;;;232    #if defined (ENABLE_PWM_CH0)
;;;233    //    SYS->GPA_MFPL = (SYS->GPA_MFPL & (~SYS_GPA_MFPL_PA5MFP_Msk)) | SYS_GPA_MFPL_PA5MFP_PWM0_CH0;
;;;234        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB5MFP_Msk)) | SYS_GPB_MFPL_PB5MFP_PWM0_CH0;
;;;235    #elif defined (ENABLE_PWM_CH4)
;;;236        SYS->GPB_MFPL = (SYS->GPB_MFPL & (~SYS_GPB_MFPL_PB1MFP_Msk)) | SYS_GPB_MFPL_PB1MFP_PWM0_CH4;	
00007e  6b81              LDR      r1,[r0,#0x38]
000080  22f0              MOVS     r2,#0xf0
000082  4391              BICS     r1,r1,r2
000084  31b0              ADDS     r1,r1,#0xb0
000086  6381              STR      r1,[r0,#0x38]
;;;237    
;;;238    #endif
;;;239    	
;;;240        /* Update System Core Clock */
;;;241        SystemCoreClockUpdate();
000088  f7fffffe          BL       SystemCoreClockUpdate
00008c  2000              MOVS     r0,#0
00008e  6020              STR      r0,[r4,#0]
;;;242    
;;;243        /* Lock protected registers */
;;;244        SYS_LockReg();
;;;245    }
000090  bdf8              POP      {r3-r7,pc}
;;;246    
                          ENDP

000092  0000              DCW      0x0000
                  |L4.148|
                          DCD      0x40000100
                  |L4.152|
                          DCD      0x40004140
                  |L4.156|
                          DCD      0x5f803d10
                  |L4.160|
                          DCD      0x5ec00003
                  |L4.164|
                          DCD      0xa2000010

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;162    
;;;163    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;164    {
;;;165        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L5.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1508              ASRS     r0,r1,#20
00001c  4904              LDR      r1,|L5.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;166        TIMER_EnableInt(TIMER1);
;;;167        NVIC_EnableIRQ(TMR1_IRQn);	
;;;168        TIMER_Start(TIMER1);
;;;169    }
000028  bd10              POP      {r4,pc}
;;;170    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40050020
                  |L5.48|
                          DCD      0xe000e100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR1_IRQHandler PROC
;;;113    
;;;114    void TMR1_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  4920              LDR      r1,|L6.132|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;115    {
00000a  d039              BEQ      |L6.128|
00000c  2601              MOVS     r6,#1
00000e  608e              STR      r6,[r1,#8]
;;;116    	static uint32_t LOG = 0;
;;;117    	static uint16_t CNT = 0;
;;;118    
;;;119    	static uint16_t CNT_PWM = 1;
;;;120    	static uint16_t duty = 500;	// 1 ~ 1000 , 0.1 % to 100%
;;;121    
;;;122        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;123        {
;;;124            TIMER_ClearIntFlag(TIMER1);
;;;125    
;;;126    		if (CNT_PWM++ == 500)
000010  4d1d              LDR      r5,|L6.136|
;;;127    		{
;;;128    			CNT_PWM = 1;
;;;129    			
;;;130    //			PWM_Set_Duty(PWM0, PWM_CHANNEL, duty, 1000);
;;;131    			CalNewDuty(PWM0, PWM_CHANNEL, duty, 1000);
000012  277d              MOVS     r7,#0x7d
000014  88a8              LDRH     r0,[r5,#4]            ;126  ; CNT_PWM
000016  00ff              LSLS     r7,r7,#3
000018  1c41              ADDS     r1,r0,#1              ;126
00001a  80a9              STRH     r1,[r5,#4]            ;126
00001c  4601              MOV      r1,r0                 ;126
00001e  39ff              SUBS     r1,r1,#0xff           ;126
000020  39f5              SUBS     r1,r1,#0xf5           ;126
000022  d11f              BNE      |L6.100|
000024  4819              LDR      r0,|L6.140|
000026  80ae              STRH     r6,[r5,#4]            ;128
000028  6800              LDR      r0,[r0,#0]
00002a  88ec              LDRH     r4,[r5,#6]  ; duty
00002c  1c40              ADDS     r0,r0,#1
00002e  4360              MULS     r0,r4,r0
000030  4639              MOV      r1,r7
000032  f7fffffe          BL       __aeabi_uidivmod
000036  4a15              LDR      r2,|L6.140|
000038  6210              STR      r0,[r2,#0x20]
;;;132    
;;;133    			if (is_flag_set(flag_reverse))
00003a  7828              LDRB     r0,[r5,#0]  ; BitFlag
00003c  07c1              LSLS     r1,r0,#31
00003e  d001              BEQ      |L6.68|
000040  1c64              ADDS     r4,r4,#1
;;;134    			{
;;;135    				duty++;	
000042  e000              B        |L6.70|
                  |L6.68|
000044  1e64              SUBS     r4,r4,#1
                  |L6.70|
;;;136    			}
;;;137    			else
;;;138    			{
;;;139    				duty--;
;;;140    			}
;;;141    
;;;142    			if (duty == 1000)
000046  b2a1              UXTH     r1,r4
000048  80ec              STRH     r4,[r5,#6]            ;139
00004a  42b9              CMP      r1,r7
00004c  d102              BNE      |L6.84|
;;;143    			{
;;;144    				set_flag(flag_reverse , DISABLE);				
00004e  0840              LSRS     r0,r0,#1
000050  0040              LSLS     r0,r0,#1
000052  e002              B        |L6.90|
                  |L6.84|
;;;145    			}
;;;146    			else if (duty == 0)
000054  2900              CMP      r1,#0
000056  d101              BNE      |L6.92|
;;;147    			{
;;;148    				set_flag(flag_reverse , ENABLE);
000058  4330              ORRS     r0,r0,r6
                  |L6.90|
00005a  7028              STRB     r0,[r5,#0]
                  |L6.92|
;;;149    			}
;;;150    			
;;;151    			PB14 ^= 1;
00005c  480c              LDR      r0,|L6.144|
00005e  6b81              LDR      r1,[r0,#0x38]
000060  4071              EORS     r1,r1,r6
000062  6381              STR      r1,[r0,#0x38]
                  |L6.100|
;;;152    		}		
;;;153    
;;;154    		if (CNT++ >= 1000)
000064  8868              LDRH     r0,[r5,#2]  ; CNT
000066  1c41              ADDS     r1,r0,#1
000068  8069              STRH     r1,[r5,#2]
00006a  42b8              CMP      r0,r7
00006c  d308              BCC      |L6.128|
;;;155    		{		
;;;156    			CNT = 0;		
00006e  2000              MOVS     r0,#0
000070  8068              STRH     r0,[r5,#2]
;;;157            	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
000072  68aa              LDR      r2,[r5,#8]  ; LOG
000074  4907              LDR      r1,|L6.148|
000076  1c50              ADDS     r0,r2,#1
000078  60a8              STR      r0,[r5,#8]  ; LOG
00007a  a007              ADR      r0,|L6.152|
00007c  f7fffffe          BL       __2printf
                  |L6.128|
;;;158    		}
;;;159        }
;;;160    }
000080  bdf8              POP      {r3-r7,pc}
;;;161    
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      0x40050020
                  |L6.136|
                          DCD      ||.data||
                  |L6.140|
                          DCD      0x40058040
                  |L6.144|
                          DCD      0x40004840
                  |L6.148|
                          DCD      ||.constdata||
                  |L6.152|
000098  2573203a          DCB      "%s : %4d\r\n",0
00009c  20253464
0000a0  0d0a00  
0000a3  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;170    
;;;171    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173        SYS_ResetModule(UART0_RST);
000002  4819              LDR      r0,|L7.104|
000004  f7fffffe          BL       SYS_ResetModule
;;;174    
;;;175        /* Configure UART0 and set UART0 baud rate */
;;;176        UART_Open(UART0, 115200);
000008  4c18              LDR      r4,|L7.108|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;177    
;;;178    	/* Set UART receive time-out */
;;;179    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;180    
;;;181    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00001c  f7fffffe          BL       CLK_GetCPUFreq
000020  4601              MOV      r1,r0
000022  a013              ADR      r0,|L7.112|
000024  f7fffffe          BL       __2printf
;;;182    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
000028  f7fffffe          BL       CLK_GetHCLKFreq
00002c  4601              MOV      r1,r0
00002e  a017              ADR      r0,|L7.140|
000030  f7fffffe          BL       __2printf
;;;183    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000034  f7fffffe          BL       CLK_GetHXTFreq
000038  4601              MOV      r1,r0
00003a  a01a              ADR      r0,|L7.164|
00003c  f7fffffe          BL       __2printf
;;;184    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000040  f7fffffe          BL       CLK_GetLXTFreq
000044  4601              MOV      r1,r0
000046  a01d              ADR      r0,|L7.188|
000048  f7fffffe          BL       __2printf
;;;185    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00004c  f7fffffe          BL       CLK_GetPCLK0Freq
000050  4601              MOV      r1,r0
000052  a020              ADR      r0,|L7.212|
000054  f7fffffe          BL       __2printf
;;;186    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000058  f7fffffe          BL       CLK_GetPCLK1Freq
00005c  4601              MOV      r1,r0
00005e  a024              ADR      r0,|L7.240|
000060  f7fffffe          BL       __2printf
;;;187    	
;;;188    }
000064  bd10              POP      {r4,pc}
;;;189    
                          ENDP

000066  0000              DCW      0x0000
                  |L7.104|
                          DCD      0x04000010
                  |L7.108|
                          DCD      0x40070000
                  |L7.112|
000070  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000074  4b5f4765
000078  74435055
00007c  46726571
000080  203a2025
000084  38640d0a
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L7.140|
00008c  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
000090  47657448
000094  434c4b46
000098  72657120
00009c  3a202538
0000a0  640d0a00
                  |L7.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L7.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L7.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b30
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L7.240|
0000f0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f4  47657450
0000f8  434c4b31
0000fc  46726571
000100  203a2025
000104  38640d0a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;254    
;;;255    int main()
000000  f7fffffe          BL       SYS_Init
;;;256    {
;;;257        SYS_Init();
;;;258    
;;;259        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;260    	
;;;261    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;262    
;;;263    	PWM0_Init();
00000c  f7fffffe          BL       PWM0_Init
;;;264    
;;;265    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
                  |L8.20|
;;;266    	
;;;267    	
;;;268        /* Got no where to go, just loop forever */
;;;269        while(1)
000014  e7fe              B        |L8.20|
;;;270        {
;;;271    
;;;272        }
;;;273    }
;;;274    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  544d5231          DCB      0x54,0x4d,0x52,0x31
000004  5f495251          DCB      0x5f,0x49,0x52,0x51
000008  48616e64          DCB      0x48,0x61,0x6e,0x64
00000c  6c657200          DCB      0x6c,0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
000000  0000              DCB      0x00,0x00
                  ||CNT||
000002  0000              DCW      0x0000
                  CNT_PWM
000004  0001              DCW      0x0001
                  duty
000006  01f4              DCW      0x01f4
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
